# import yaml

# data = {}
# with open("data.yml") as f:
#     data = yaml.safe_load(f)

# e = data["public"]["e"]
# n = data["public"]["n"]
# encrypted_message = data["encrypted_message"]

# print(encrypted_message)
# print(e)
# print(n)

# modulusSize = 1024
# primeSize = modulusSize // 2

# minPrime = 2 ** (primeSize - 1)
# maxPrime = (2 ** primeSize) - 1

# 1.87 X 10^152
# 187000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
# 187000000000000027488611947882983619420766229835863457926215988881663798015793909988897343078994577611692703283167340739983833713815078196923860470726656
# This many possible primes of bit length 512

# 6.7039 X 10^153
# 6703900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
# 6703899999999999808997451922873332758237558688492264089231861717665535606487046467900311203021228626507173204166906595508421406866140062496247607610834944
# This many numbers of bit length 512

# 2.789421083250049% of numbers with bit length 512 are prime

# ==========================================================

# 1.28 X 10^306
# 1280000000000000078169571389486656883739274970178030568028048482649490613952197254971122637215202631249758637223352905694954460501596102843216900094880465740446171325537752125757110111708360913880630622567072978326603375033999256559391853176827816707026110317092259073263994210416723615654845196432308174848
# This many possible primes of bit length 1024

# 8.988 X 10^307
# 89879999999999993370671617829617331635636214989391919374131431971652059388214171453201820713904151347076654883247554500100920189589772460390658976157340256792227389800319504893363255760647255277228594926499943970164886249260581167101755670031851259360886527992663327249462891802530181590509809482035942653952
# This many numbers of bit length 1024

# 1.4241210502892747% of numbers with bit length 1024 are prime

"""
n = a * b

n = 
last digits of p => last digits of n
1 => 0,1,2,3,4,5,6,7,8,9
3 => 0,1,2,3,4,5,6,7,8,9
7 => 0,1,2,3,4,5,6,7,8,9
9 => 0,1,2,3,4,5,6,7,8,9

last digits of n => last digits of n
1 => 0,1,2,3,4,5,6,7,8,9
3 => 0,1,2,3,4,5,6,7,8,9
7 => 0,1,2,3,4,5,6,7,8,9
9 => 0,1,2,3,4,5,6,7,8,9

last possible digits of p, q, AND n: 1,3,7,9
=============================
(p, q) = n

(1, 1) = 1
(3, 7) = 1
(7, 3) = 1
(9, 9) = 1
(1, 3) = 3
(3, 1) = 3
(7, 9) = 3
(9, 7) = 3
(1, 7) = 7
(3, 9) = 7
(7, 1) = 7
(9, 3) = 7
(1, 9) = 9
(3, 3) = 9
(7, 7) = 9
(9, 1) = 9

p: 10504254919402784438337690091379174283630649177048581094076369806294194075180615604766975556687272654622579158173524942161290946569497828216212657869258139
q: 13217545963041553031717769347003958049383956681272746612495882757898077044975472964588563262609998730961602367191042137892841630143365690022291137687045189

n: 13884047220471164746174703669556932035571124738694764632474343628669084175942571512892644068331943574031009693476374746620131227390167182073289497362879406
      1648487905564105066805060541987308179206519620058463830857993438442412595511535351244762877436296689927345196723801166577486291885446029654790838399043271


"""

"""
for each possible ending n digits of p and q:
  generate a list of possible ending (n+1) digits of p and q
"""

def generate_ending_digits(possible, new_length, ending):
    """
    possible => {(a1,b1), (a2,b2), ...}
    length => 2
    ending => 71 ; 03 ; etc
    """

    ending_string = str(ending).zfill(new_length)

    new_possible = set()

    for item in possible:

        p = str(item[0]).zfill(new_length - 1)
        q = str(item[1]).zfill(new_length - 1)

        for p_base in range(10):
            for q_base in range(10):
                p_ending = str(p_base) + p
                q_ending = str(q_base) + q

                p_ending_int = int(p_ending)                
                q_ending_int = int(q_ending)

                possible_ending = str(p_ending_int * q_ending_int).zfill(new_length)
                possible_ending = possible_ending[((new_length) * -1):]

                if possible_ending == ending_string:
                    new_combo = tuple(sorted((p_ending, q_ending)))
                    new_possible.add(new_combo)

    return new_possible

import time
import itertools
def find_primes(n):
    # old_possible = [(1, 1),(1, 3),(1, 7),(1, 9),(3, 3),(3, 7),(3, 9),(7, 7),(7, 9),(9, 9)]

    a = [1,3,7,9]
    old_possible = set(itertools.combinations_with_replacement(a, 2))

    str_n = str(n)

    for i in range(len(str_n)):
        if i < 2:
            continue
        ending = str_n[(i * -1):]
        
        new_possible = generate_ending_digits(old_possible, i, ending)
        print(f"{len(new_possible)} possible p and q endings")

        old_possible = new_possible

    return old_possible


n = 138840472204711647461747036695569320355711247386947646324743436286690841759425715128926440683319435740310096934763747466201312273901671820732894973628794061648487905564105066805060541987308179206519620058463830857993438442412595511535351244762877436296689927345196723801166577486291885446029654790838399043271
possible = find_primes(n)

with open("possible.txt", "w") as f:
    for item in possible:
        f.write(str(item))
        f.write("\n")